# 유니티 스크립트 예제
***
## 유니티의 생명주기
> 유니티에서는 프로그램의 실행부터 종료까지의 작업 영역을 함수로 제공합니다.

|제목|내용|설명|역할|
|------|---|---|---|
|Awake()|씬이 시작될 때 한 번만 호출|해당 스크립트가 비활성화 되어 있어도 이 위치의 작업은 실행되며, 코루틴 사용 불가능|주로 변수 초기화, 값 참조할 때 사용|
|OnEnable()|오브젝트 또는 스크립트가 활성화 될 때 호출|이벤트에 대한 연결에 사용하며, 코루틴 사용 불가능, 반대의 개념은 OnDisable()|활성화 시 구현되어야 하는 기능에 사용|
|Start()|모든 스크립트의 Awake()가 다 실행된 이후 호출|Awake()를 사용해도 무방하며 상황에 따라 설계, 코루틴 사용 가능|게임 로직에 대한 실행, 초기화된 데이터를 기반으로 작업 수행할 때 사용|
|Update()|프레임마다 호출(1초에 약 60번)|프로그램 내에서 핵심적으로 자주 사용되는 메인 로직을 짤 때 사용되며, 가장 많이 사용되는 영역|계산에 대한 보정 값, 키 입력 기반 움직임 등의 정규화/단위 벡터를 이용한 작업 처리
|FixedUpdate()|프레임마다 호출되는 것이 아닌, Fixed TimeStep이라는 설정 값에 의해 호출(default: 0.02초)|일정한 발생 주기가 보장되어야 하는 로직을 구현할 때 사용|물리 연산(Rigidbody)이 적용된 오브젝트에 대한 조정|
|LateUpdate()|모든 Update 함수(Update, FixedUpdate)가 호출된 이후 마지막으로 호출|후처리 작업에 사용|렌더링 이후 동작하는 카메라 처리와 같은 후처리 작업|

[이벤트 함수의 실행 순서](https://docs.unity3d.com/kr/current/Manual/ExecutionOrder.html)

<br>

## 오브젝트 캐싱(Object Cashing)
### 캐시(Cashe): 자주 사용되는 데이터나 값을 미리 복사해두는 임시 저장소
#### 캐시 사용 의도
> 1. 시간 지역성: 가장 최근에 사용된 값이 다시 사용될 가능성이 높다.
> 2. 공간 지역성: 최근에 접근한 주소와 인접한 주소의 변수가 사용될 가능성이 높다.

*예시 코드*
```cs
using UnityEngine;
public class Sample3 : MonoBehaviour
{
    Rigidbody rb;
    Vector3 pos;

    void Start()
    {
        rb = GetComponent<Rigidbody>(); // 캐싱(cashing)
    }

    void Update()
    {
        GetComponent<Rigidbody>().AddForce(pos * 5); // 프레임마다 호출
    }
}
```

<br>

## 유니티의 벡터
### 벡터(Vector): 벡터는 크기와 방향을 가진 물리량으로 유니티에서 위치(Position), 이동(Movement), 방향(Direction), 힘(Force)등을 표현할 때 사용합니다.
#### 벡터의 요소
> 1. X: X축의 값
> 2. Y: Y축의 값
> 3. Z: Z축의 값
> 4. W: 셰이더나 수학 계산 등에서 사용되는 Vector4에서의 W축의 값

#### 벡터의 특징
> 1. 값 타입(value)으로 참조가 아닌 값 그 자체를 의미합니다.(구조체 struct)
> 2. 값을 복사할 경우 값 그 자체를 복사하기만 하면 됩니다.
> 3. 벡터에 대한 계산 보조 기능이 많이 제공됩니다.(magnitude, normalize, Dot, Cross, ...)
> 4. 벡터는 스택(stack) 영역의 메모리에서 저장됩니다.

#### 값(Value) vs 참조(Reference)
> 값: 변수에 데이터가 직접 저장되는 경우
> > ex) int a = 5;

> 참조: 변수에 데이터가 저장된 메모리 주소 값이 저장되는 경우
> > ex) VectorSample = new VectorSample(); (클래스는 대표적인 참조 타입)

#### 메모리 저장 영역
> 프로그램이 실행되기 위해서는 운영체제(OS)가 프로그램의 정보를 메모리에 로드해야 합니다.

> 프로그램이 실행되는 동안 중앙 제어 장치(CPU)가 코드를 처리하기 위해 메모리가 명령어와 데이터들을 저장하고 있어야 합니다.

> 컴퓨터 메모리는 바이트(byte) 단위로 번호가 새겨진 선형 공간을 의미합니다.

> 낮은 주소부터 높은 주소까지 저장되는 영역이 다르게 설정되어 있습니다.
> > 낮은 주소: 메모리의 시작 부분

> > 높은 주소: 메모리의 끝 부분

#### 대표적인 메모리 공간
|제목|내용|설명|
|------|---|---|
|코드(Code)|실행할 프로그램 코드가 저장되는 영역(텍스트 영역)|프로그램 시작부터 종료까지 계속 남아있는 값, CPU에서 저장된 명령을 하나씩 가져가서 처리합니다.|
|데이터(Data)|프로그램에서 전역 변수, 정적 변수가 저장되는 영역|전역 변수(global): 프로그램 어디서나 접근 가능한 변수<br><br>정적 변수(static): 프로그램 시작부터 할당되고 그 이후부터 종료 시점까지 유지되는 변수, static 키워드가 붙은 변수는 별도의 객체 생성 없이 클래스명.변수명으로 직접 접근하는 것이 가능합니다.|
|힙(Heap)|프로그래머가 직접 저장 공간에 대한 할당과 해제를 진행하는 영역<br>값에 대한 등록도, 값에 대한 제거도 프로그래머가 설계합니다.|참조 타입은 힙에 저장됩니다.<br>C#의 힙 영역의 데이터는 GC에 의해 자동으로 관리됩니다.<br>저장 순서, 정렬에 대한 작업을 따로 신경 쓸 필요가 없습니다.<br>단, 메모리가 크고 GC에 의해 자동으로 처리되는 만큼, 많이 사용되면 그만큼 성능이 저하됩니다.|
|스택(Stack)|프로그램이 자동으로 사용하는 임시 메모리 영역<br>함수 호출 시 생성되는 변수(지역 변수, 매개변수)가 저장되는 영역|함수의 호출이 완료되면 사라지는 데이터, 이 때의 호출 정보 == stack frame(스택 프레임)<br>매우 빠른 속도로 접근이 가능합니다.(할당과 해제의 비용이 사실 상 없음)<br>먼저 들어온 데이터가 누적되고 가장 마지막에 남은 데이터가 먼저 제거되는 방식(LIFO)|

#### 선형 보간과 구면 선형 보간
> 선형 보간: 두 지점을 선형으로 연결해서 두 지점사이의 위치를 파악하는 방법(Lerp)<br>
> 구면 선형 보간: 두 지점 사이의 위치를 곡선으로 파악하는 방법(Slerp)

#### Lerp와 Slerp
> Lerp: 직선 이동
> > 체력 게이지 등이 일정하게 변화하는 경우

> Slerp: 곡선 이동
> > 회전이나 각도의 개념이 필요한 경우<br>
> > 3D 회전(쿼터니언) / 벡터 간의 곡선 경로 확인 / 방향 회전이 부드럽게 대상 방향을 바라봐야 할 경우

#### Lerp와 Slerp가 사용되는 경우
1. 단순한 위치 이동? -> Lerp
2. 회전 및 방향 전환? -> Slerp(Vector3.Slerp, Quaternion.Slerp)
3. 자연스러운 카메라의 움직임? -> Slerp
